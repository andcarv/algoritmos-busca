package kernel.mopso.lider;

import java.util.ArrayList;
import java.util.Iterator;

import kernel.AlgoritmoAprendizado;
import kernel.mopso.Particula;
import solucao.Solucao;
import solucao.SolucaoNumerica;

public class EscolherExploiting extends EscolherLider {

private int m;
	
	public EscolherExploiting(int m){
		this.m = m;
		id = "exploiting";
	}
	
	public void escolherLideres(ArrayList<Particula> populacao,	ArrayList<Solucao> lideres) {
		ArrayList<ArrayList<Solucao>> extremos = obterSolucoesExtremas(lideres);
		
		
		for (Iterator<Particula> iterator = populacao.iterator(); iterator.hasNext();) {
			Particula particula = iterator.next();
			double menorObjetivo = Double.MAX_VALUE;
			int menorIndice = 0;
			for(int i = 0; i<m; i++){				
				if(particula.solucao.objetivos[i]<menorObjetivo){
					menorObjetivo = particula.solucao.objetivos[i];
					menorIndice = i;
				}
			}
			
			ArrayList<Solucao> extremos_i = extremos.get(menorIndice);
			
			double menorDist = Double.MAX_VALUE;
			for (Iterator<Solucao> iterator2 = extremos_i.iterator(); iterator2
					.hasNext();) {
				Solucao solucao = (Solucao) iterator2.next();
				
				solucao.menorDistancia = AlgoritmoAprendizado.distanciaEuclidiana(solucao.objetivos, particula.solucao.objetivos);
				if(solucao.menorDistancia<menorDist){
					menorDist = solucao.menorDistancia;
					particula.globalBestSolucao = solucao;
					particula.globalBest =  ((SolucaoNumerica)solucao).getVariaveis();
				}
			}			
		}

	}
	
	
	/**
	 * Metodo que encontra as solucoes nos extremos dos objetivos
	 * @param solucoes
	 * @return Array com as solucoes nos extremos
	 */
	public ArrayList<ArrayList<Solucao>> obterSolucoesExtremas(ArrayList<Solucao> solucoes){
		
		ArrayList<ArrayList<Solucao>> extremos2 = new ArrayList<ArrayList<Solucao>>();
		
		for(int i = 0; i<m; i++){
			ArrayList<Solucao> extremo_i = new ArrayList<Solucao>();
			extremos2.add(extremo_i);
		}
		
		//Solucao[] extremos = new Solucao[problema.m+1];
	
		
		double[] ideal = new double[m];
		
		for (int i = 0; i < ideal.length; i++) {
			ideal[i] = Double.POSITIVE_INFINITY;	
		}
		
		//Obtem a solucoes no extremo e calcula a solucao ideal
		for (Iterator<Solucao> iter = solucoes.iterator(); iter.hasNext();) {
			Solucao rep = iter.next();
			
			for(int j = 0; j<m;j++){
				if(rep.objetivos[j]<=ideal[j]){
					if(rep.objetivos[j]<ideal[j])
						extremos2.get(j).clear();
					ideal[j] = rep.objetivos[j];
					//extremos[j] = rep;
					extremos2.get(j).add(rep);
				}
			}
		}	
	
		
		
		return extremos2;		
	}

}
